// SPDX-FileCopyrightText: 2022 Rinkashikachi <15rinkashikachi15@gmail.com>
// SPDX-FileCopyrightText: 2022 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Kara <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 Rane <60792108+Elijahrane@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Fishfish458 <47410468+Fishfish458@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023-2024 Whisper <121047731+QuietlyWhisper@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Artjom <artjombebenin@gmail.com>
// SPDX-FileCopyrightText: 2023 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 MilenVolf <63782763+MilenVolf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Saphire Lattice <lattice@saphi.re>
// SPDX-FileCopyrightText: 2024 goet <6637097+goet@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Thomas <87614336+Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 KrasnoshchekovPavel <119816022+KrasnoshchekovPavel@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Rainfey <rainfey0+github@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Krunklehorn <42424291+Krunklehorn@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Hannah Giovanna Dawson <karakkaraz@gmail.com>
// SPDX-FileCopyrightText: 2025 LordCarve <27449516+LordCarve@users.noreply.github.com>
// SPDX-FileCopyrightText: 2026 Fruitsalad <949631+Fruitsalad@users.noreply.github.com>
// SPDX-License-Identifier: MIT

using Content.Client.UserInterface.Controls;
using Content.Client.Medical.Surgery.Controls;
using Content.Shared.Medical;
using Content.Shared.MedicalScanner;
using Content.Shared.Medical.Surgery;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Client.UserInterface.Controls;
using Robust.Client.GameObjects;
using Robust.Shared.IoC;

namespace Content.Client.HealthAnalyzer.UI;

public enum HealthAnalyzerMode
{
    Health,
    Integrity,
    Surgery
}

[GenerateTypedNameReferences]
public sealed partial class HealthAnalyzerWindow : FancyWindow
{
    private NetEntity? _currentTargetEntity;
    private HealthAnalyzerMode _currentMode = HealthAnalyzerMode.Health;
    private HealthAnalyzerUiState? _currentState;
    private readonly IEntityManager _entMan;
    public event Action<NetEntity>? OnBeginSurgeryClicked;
    public event Action<NetEntity, NetEntity, SurgeryLayer, TargetBodyPart?, bool>? OnAttemptSurgery;

    public HealthAnalyzerWindow()
    {
        RobustXamlLoader.Load(this);
        _entMan = IoCManager.Resolve<IEntityManager>();
        
        BeginSurgeryButton.OnPressed += OnBeginSurgeryButtonPressed;
        
        // Subscribe to mode button presses
        HealthModeButton.OnPressed += _ => SetMode(HealthAnalyzerMode.Health);
        IntegrityModeButton.OnPressed += _ => SetMode(HealthAnalyzerMode.Integrity);
        SurgeryModeButton.OnPressed += _ => SetMode(HealthAnalyzerMode.Surgery);
        
        // Set initial mode
        SetMode(HealthAnalyzerMode.Health);
    }

    public void Populate(HealthAnalyzerScannedUserMessage msg)
    {
        _currentState = msg.State;
        HealthAnalyzerControl.Populate(msg.State, _currentMode);
        
        // Store current target entity
        _currentTargetEntity = msg.State.TargetEntity;
        
        // Update surgery UI based on mode
        UpdateSurgeryUI();
    }
    
    private void SetMode(HealthAnalyzerMode mode)
    {
        _currentMode = mode;
        
        // Update button pressed states
        HealthModeButton.Pressed = mode == HealthAnalyzerMode.Health;
        IntegrityModeButton.Pressed = mode == HealthAnalyzerMode.Integrity;
        SurgeryModeButton.Pressed = mode == HealthAnalyzerMode.Surgery;
        
        // Update UI visibility
        if (_currentState.HasValue)
        {
            HealthAnalyzerControl.Populate(_currentState.Value, mode);
        }
        
        // Update surgery UI based on mode
        UpdateSurgeryUI();
    }
    
    private void UpdateSurgeryUI()
    {
        bool showSurgeryPanel = _currentMode == HealthAnalyzerMode.Surgery && _currentTargetEntity != null;
        SurgeryPanel.Visible = showSurgeryPanel;
        
        // Hide BeginSurgeryButton when surgery panel is shown
        BeginSurgeryButton.Visible = false;
        
        if (showSurgeryPanel && _currentState.HasValue)
        {
            PopulateSurgerySteps(_currentState.Value);
        }
        else
        {
            SurgeryStepsContainer.RemoveAllChildren();
        }
    }
    
    private void PopulateSurgerySteps(HealthAnalyzerUiState state)
    {
        SurgeryStepsContainer.RemoveAllChildren();
        
        if (state.SurgerySteps == null || state.SurgerySteps.Count == 0)
        {
            var label = new Label { Text = "No surgery operations available." };
            SurgeryStepsContainer.AddChild(label);
            return;
        }
        
        var currentLayer = state.CurrentSurgeryLayer ?? SurgeryLayer.Skin;
        var selectedBodyPart = state.SelectedSurgeryBodyPart;
        
        foreach (var stepNetEntity in state.SurgerySteps)
        {
            // Get operation info for this step
            SurgeryStepOperationInfo? operationInfo = null;
            state.SurgeryStepOperationInfo?.TryGetValue(stepNetEntity, out operationInfo);
            
            // Create step control (simplified version for health analyzer)
            var stepControl = new SurgeryStepControl(
                _entMan,
                stepNetEntity,
                operationInfo,
                currentLayer
            );
            
            stepControl.OnStepSelected += (step) =>
            {
                if (_currentTargetEntity != null)
                {
                    OnAttemptSurgery?.Invoke(step, _currentTargetEntity.Value, currentLayer, selectedBodyPart, false);
                }
            };
            
            stepControl.OnToolMethodSelected += (step, isImprovised) =>
            {
                if (_currentTargetEntity != null)
                {
                    OnAttemptSurgery?.Invoke(step, _currentTargetEntity.Value, currentLayer, selectedBodyPart, isImprovised);
                }
            };
            
            SurgeryStepsContainer.AddChild(stepControl);
        }
    }
    
    private void OnBeginSurgeryButtonPressed(BaseButton.ButtonEventArgs args)
    {
        if (_currentTargetEntity == null)
            return;
            
        OnBeginSurgeryClicked?.Invoke(_currentTargetEntity.Value);
    }
    
}
