// SPDX-FileCopyrightText: 2026 Fruitsalad <949631+Fruitsalad@users.noreply.github.com>
// SPDX-License-Identifier: MIT

using System.Linq;
using System.Numerics;
using Content.Client.Clickable;
using Content.Shared.Atmos;
using Content.Shared.Damage.Components;
using Content.Shared.Damage.Prototypes;
using Content.Shared.FixedPoint;
using Content.Shared.Humanoid;
using Content.Shared.Humanoid.Prototypes;
using Content.Shared.IdentityManagement;
using Content.Shared.Medical;
using Content.Shared.Medical.Surgery;
using Content.Shared.MedicalScanner;
using Content.Shared.Mobs;
using Content.Shared.Mobs.Components;
using Robust.Client.AutoGenerated;
using Robust.Client.GameObjects;
using Robust.Client.Graphics;
using Robust.Client.ResourceManagement;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.Controls;
using Robust.Client.UserInterface.XAML;
using Robust.Client.Utility;
using Robust.Shared.Graphics.RSI;
using Robust.Shared.Input;
using Robust.Shared.Maths;
using Robust.Shared.Prototypes;
using Robust.Shared.Utility;
namespace Content.Client.HealthAnalyzer.UI;

// Health analyzer UI is split from its window because it's used by both the
// health analyzer item and the cryo pod UI.

[GenerateTypedNameReferences]
public sealed partial class HealthAnalyzerControl : BoxContainer
{
    private readonly IEntityManager _entityManager;
    private readonly SpriteSystem _spriteSystem;
    private readonly IPrototypeManager _prototypes;
    private readonly IResourceCache _cache;
    private readonly IClickMapManager _clickMapManager;

    private EntityUid? _spriteViewEntity;
    private EntityUid? _lastBodyEntity;
    private TargetBodyPart? _selectedBodyPart;
    private readonly Dictionary<TargetBodyPart, string> _highlightLayerIds = new();

    // Mapping from HumanoidVisualLayers to TargetBodyPart
    private static readonly Dictionary<HumanoidVisualLayers, TargetBodyPart> LayerToBodyPartMap = new()
    {
        { HumanoidVisualLayers.Head, TargetBodyPart.Head },
        { HumanoidVisualLayers.Chest, TargetBodyPart.Torso },
        { HumanoidVisualLayers.LArm, TargetBodyPart.LeftArm },
        { HumanoidVisualLayers.LHand, TargetBodyPart.LeftHand },
        { HumanoidVisualLayers.RArm, TargetBodyPart.RightArm },
        { HumanoidVisualLayers.RHand, TargetBodyPart.RightHand },
        { HumanoidVisualLayers.LLeg, TargetBodyPart.LeftLeg },
        { HumanoidVisualLayers.LFoot, TargetBodyPart.LeftFoot },
        { HumanoidVisualLayers.RLeg, TargetBodyPart.RightLeg },
        { HumanoidVisualLayers.RFoot, TargetBodyPart.RightFoot },
    };

    // Reverse mapping from TargetBodyPart to HumanoidVisualLayers
    private static readonly Dictionary<TargetBodyPart, HumanoidVisualLayers> BodyPartToLayerMap = new()
    {
        { TargetBodyPart.Head, HumanoidVisualLayers.Head },
        { TargetBodyPart.Torso, HumanoidVisualLayers.Chest },
        { TargetBodyPart.LeftArm, HumanoidVisualLayers.LArm },
        { TargetBodyPart.LeftHand, HumanoidVisualLayers.LHand },
        { TargetBodyPart.RightArm, HumanoidVisualLayers.RArm },
        { TargetBodyPart.RightHand, HumanoidVisualLayers.RHand },
        { TargetBodyPart.LeftLeg, HumanoidVisualLayers.LLeg },
        { TargetBodyPart.LeftFoot, HumanoidVisualLayers.LFoot },
        { TargetBodyPart.RightLeg, HumanoidVisualLayers.RLeg },
        { TargetBodyPart.RightFoot, HumanoidVisualLayers.RFoot },
    };

    public event Action<TargetBodyPart?>? OnBodyPartSelected;

    public TargetBodyPart? SelectedBodyPart => _selectedBodyPart;

    public HealthAnalyzerControl()
    {
        RobustXamlLoader.Load(this);

        var dependencies = IoCManager.Instance!;
        _entityManager = dependencies.Resolve<IEntityManager>();
        _spriteSystem = _entityManager.System<SpriteSystem>();
        _prototypes = dependencies.Resolve<IPrototypeManager>();
        _cache = dependencies.Resolve<IResourceCache>();
        _clickMapManager = dependencies.Resolve<IClickMapManager>();
    }

    public void Populate(HealthAnalyzerUiState state, HealthAnalyzerMode mode = HealthAnalyzerMode.Health, bool allowSurgery = true)
    {
        var target = _entityManager.GetEntity(state.TargetEntity);

        if (target == null
            || !_entityManager.TryGetComponent<DamageableComponent>(target.Value, out var damageable))
        {
            NoPatientDataText.Visible = true;
            PatientDataContainer.Visible = false;
            GroupsContainer.Visible = false;
            IntegrityContainer.Visible = false;
            AlertsDivider.Visible = false;
            AlertsContainer.Visible = false;
            return;
        }

        NoPatientDataText.Visible = false;
        var targetEntity = target.Value;

        // When allowSurgery is false (e.g. CryoPod), treat Surgery as Health
        var effectiveMode = (mode == HealthAnalyzerMode.Surgery && !allowSurgery) ? HealthAnalyzerMode.Health : mode;

        // Health/Integrity mode or allowSurgery=false: display-only, no click handling
        if (effectiveMode != HealthAnalyzerMode.Surgery)
        {
            CleanupSurgeryMode();
            SpriteView.OnKeyBindDown -= OnSpriteViewClick;
            SpriteView.MouseFilter = MouseFilterMode.Ignore;
        }

        // Route to appropriate display method based on mode
        switch (effectiveMode)
        {
            case HealthAnalyzerMode.Health:
                PopulateHealthMode(state, targetEntity, damageable);
                break;
            case HealthAnalyzerMode.Integrity:
                PopulateIntegrityMode(state);
                break;
            case HealthAnalyzerMode.Surgery:
                PopulateSurgeryMode(state, targetEntity, damageable);
                break;
        }
    }

    private void CleanupSurgeryMode()
    {
        if (_spriteViewEntity != null && !_entityManager.Deleted(_spriteViewEntity))
        {
            _entityManager.QueueDeleteEntity(_spriteViewEntity.Value);
            _spriteViewEntity = null;
        }
        _lastBodyEntity = null;
    }

    private void PopulateSurgeryMode(HealthAnalyzerUiState state, EntityUid target, DamageableComponent damageable)
    {
        // Show same health mode containers as Health mode
        PatientDataContainer.Visible = true;
        GroupsContainer.Visible = true;
        IntegrityContainer.Visible = false;

        // Scan Mode
        ScanModeLabel.Text = state.ScanMode.HasValue
            ? state.ScanMode.Value
                ? Loc.GetString("health-analyzer-window-scan-mode-active")
                : Loc.GetString("health-analyzer-window-scan-mode-inactive")
            : Loc.GetString("health-analyzer-window-entity-unknown-text");

        ScanModeLabel.FontColorOverride = state.ScanMode.HasValue && state.ScanMode.Value ? Color.Green : Color.Red;

        // Patient Information - use sprite copy for highlighting
        var showSprite = state.ScanMode.HasValue && state.ScanMode.Value;
        if (showSprite)
        {
            if (_spriteViewEntity == null || _entityManager.Deleted(_spriteViewEntity))
            {
                _spriteViewEntity = _entityManager.Spawn("AlertSpriteView");
            }

            var needsSpriteCopy = _lastBodyEntity != target;
            if (needsSpriteCopy && _entityManager.TryGetComponent<SpriteComponent>(target, out var bodySprite) &&
                _entityManager.TryGetComponent<SpriteComponent>(_spriteViewEntity, out var viewSprite))
            {
                _spriteSystem.CopySprite((target, bodySprite), (_spriteViewEntity.Value, viewSprite));
                _lastBodyEntity = target;
            }

            SpriteView.SetEntity(_spriteViewEntity.Value);
            SpriteView.OverrideDirection = Robust.Shared.Maths.Direction.South;
            SpriteView.Visible = true;
            NoDataTex.Visible = false;

            // Subscribe to click handler (use named method for unsubscribe)
            SpriteView.OnKeyBindDown += OnSpriteViewClick;
            SpriteView.MouseFilter = MouseFilterMode.Stop;

            // Default to torso if no selection
            if (!_selectedBodyPart.HasValue)
                _selectedBodyPart = TargetBodyPart.Torso;

            UpdateBodyPartHighlight();
        }
        else
        {
            SpriteView.SetEntity(target);
            SpriteView.Visible = false;
            NoDataTex.Visible = true;
        }

        var name = new FormattedMessage();
        name.PushColor(Color.White);
        name.AddText(_entityManager.HasComponent<MetaDataComponent>(target)
            ? Identity.Name(target, _entityManager)
            : Loc.GetString("health-analyzer-window-entity-unknown-text"));
        NameLabel.SetMessage(name);

        SpeciesLabel.Text =
            _entityManager.TryGetComponent<HumanoidAppearanceComponent>(target,
                out var humanoidAppearanceComponent)
                ? Loc.GetString(_prototypes.Index<SpeciesPrototype>(humanoidAppearanceComponent.Species).Name)
                : Loc.GetString("health-analyzer-window-entity-unknown-species-text");

        TemperatureLabel.Text = !float.IsNaN(state.Temperature)
            ? $"{state.Temperature - Atmospherics.T0C:F1} °C ({state.Temperature:F1} K)"
            : Loc.GetString("health-analyzer-window-entity-unknown-value-text");

        BloodLabel.Text = !float.IsNaN(state.BloodLevel)
            ? $"{state.BloodLevel * 100:F1} %"
            : Loc.GetString("health-analyzer-window-entity-unknown-value-text");

        StatusLabel.Text =
            _entityManager.TryGetComponent<MobStateComponent>(target, out var mobStateComponent)
                ? GetStatus(mobStateComponent.CurrentState)
                : Loc.GetString("health-analyzer-window-entity-unknown-text");

        DamageLabel.Text = damageable.TotalDamage.ToString();

        var showAlerts = state.Unrevivable == true || state.Bleeding == true;
        AlertsDivider.Visible = showAlerts;
        AlertsContainer.Visible = showAlerts;

        if (showAlerts)
            AlertsContainer.RemoveAllChildren();

        if (state.Unrevivable == true)
            AlertsContainer.AddChild(new RichTextLabel
            {
                Text = Loc.GetString("health-analyzer-window-entity-unrevivable-text"),
                Margin = new Thickness(0, 4),
                MaxWidth = 300
            });

        if (state.Bleeding == true)
            AlertsContainer.AddChild(new RichTextLabel
            {
                Text = Loc.GetString("health-analyzer-window-entity-bleeding-text"),
                Margin = new Thickness(0, 4),
                MaxWidth = 300
            });

        var damageSortedGroups =
            damageable.DamagePerGroup.OrderByDescending(damage => damage.Value)
                .ToDictionary(x => x.Key, x => x.Value);

        IReadOnlyDictionary<string, FixedPoint2> damagePerType = damageable.Damage.DamageDict;
        DrawDiagnosticGroups(damageSortedGroups, damagePerType);
    }

    private void OnSpriteViewClick(GUIBoundKeyEventArgs args)
    {
        if (args.Function != EngineKeyFunctions.Use)
            return;

        if (_spriteViewEntity == null || !_entityManager.TryGetComponent<SpriteComponent>(_spriteViewEntity, out var sprite))
            return;

        var spriteEntity = _spriteViewEntity.Value;
        var clickPosUI = args.RelativePosition;

        var spriteViewScale = SpriteView.Scale;
        var spriteViewUIScale = SpriteView.UIScale;
        var spriteViewSize = SpriteView.Size;
        var spriteViewPixelSize = SpriteView.PixelSize;
        var spriteViewStretch = SpriteView.Stretch;
        var spriteViewOverrideDirection = SpriteView.OverrideDirection;

        var spriteBoundsMeters = _spriteSystem.GetLocalBounds((spriteEntity, sprite));
        var spriteSizeWorldPixels = spriteBoundsMeters.Size * EyeManager.PixelsPerMeter;
        var spriteSizeUIPixels = spriteSizeWorldPixels * spriteViewScale;

        var stretchVec = spriteViewStretch switch
        {
            SpriteView.StretchMode.Fit => Vector2.Min(spriteViewSize / spriteSizeUIPixels, Vector2.One),
            SpriteView.StretchMode.Fill => spriteViewSize / spriteSizeUIPixels,
            _ => Vector2.One,
        };
        var stretch = MathF.Min(stretchVec.X, stretchVec.Y);

        var spriteOffset = SpriteView.SpriteOffset
            ? Vector2.Zero
            : -(-SpriteView.EyeRotation).RotateVec(sprite.Offset * spriteViewScale) * new Vector2(1, -1) * EyeManager.PixelsPerMeter;

        var controlCenter = spriteViewPixelSize / 2f;
        var clickRelativeToCenter = clickPosUI - controlCenter;
        clickRelativeToCenter = new Vector2(clickRelativeToCenter.X, -clickRelativeToCenter.Y);

        if (!SpriteView.SpriteOffset)
        {
            var offsetScale = stretch * spriteViewUIScale;
            clickRelativeToCenter -= spriteOffset / offsetScale;
        }

        var totalScale = spriteViewScale * spriteViewUIScale * stretch;
        var clickInWorldPixels = clickRelativeToCenter / totalScale;
        var clickInMeters = clickInWorldPixels / EyeManager.PixelsPerMeter;

        var spriteBounds = spriteBoundsMeters;
        if (!spriteBounds.Contains(clickInMeters))
            return;

        var hitLayers = new List<(TargetBodyPart bodyPart, int layerIndex)>();

        foreach (var (humanoidLayer, targetBodyPart) in LayerToBodyPartMap)
        {
            if (!_spriteSystem.LayerMapTryGet((spriteEntity, sprite), humanoidLayer, out var layerIndex, false))
                continue;

            if (!_spriteSystem.TryGetLayer((spriteEntity, sprite), layerIndex, out var layer, false))
                continue;

            if (!_spriteSystem.IsVisible(layer))
                continue;

            var layerClickPos = clickInMeters - layer.Offset;
            var direction = spriteViewOverrideDirection;
            var isHit = CheckLayerHit(layer, layerClickPos, direction);

            if (isHit)
                hitLayers.Add((targetBodyPart, layerIndex));
        }

        if (hitLayers.Count > 0)
        {
            var topmostHit = hitLayers.OrderByDescending(x => x.layerIndex).First();
            _selectedBodyPart = topmostHit.bodyPart;
            UpdateBodyPartHighlight();
            OnBodyPartSelected?.Invoke(_selectedBodyPart);
        }
    }

    private bool CheckLayerHit(SpriteComponent.Layer layer, Vector2 layerClickPos, Direction? overrideDirection = null)
    {
        Vector2i imagePos;
        Vector2i size;

        if (layer.Texture != null)
        {
            size = layer.Texture.Size;
            imagePos = (Vector2i)(layerClickPos * EyeManager.PixelsPerMeter * new Vector2(1, -1) + size / 2f);

            if (imagePos.X >= 0 && imagePos.X < size.X && imagePos.Y >= 0 && imagePos.Y < size.Y)
            {
                return _clickMapManager.IsOccluding(layer.Texture, imagePos);
            }
        }
        else if (layer.RSI != null && layer.State != null)
        {
            var rsiState = layer.RSI[layer.State];
            if (rsiState == null)
                return false;

            size = rsiState.Size;
            var direction = RsiDirection.South;
            if (overrideDirection.HasValue)
            {
                var dirType = rsiState.RsiDirections;
                direction = overrideDirection.Value.Convert(dirType);
            }
            var frame = 0;
            imagePos = (Vector2i)(layerClickPos * EyeManager.PixelsPerMeter * new Vector2(1, -1) + size / 2f);

            if (imagePos.X >= 0 && imagePos.X < size.X && imagePos.Y >= 0 && imagePos.Y < size.Y)
            {
                return _clickMapManager.IsOccluding(layer.RSI, layer.State, direction, frame, imagePos);
            }
        }

        return false;
    }

    private void UpdateBodyPartHighlight()
    {
        if (_spriteViewEntity == null || !_entityManager.TryGetComponent<SpriteComponent>(_spriteViewEntity, out var sprite))
            return;

        var spriteEntity = _spriteViewEntity.Value;

        foreach (var layerId in _highlightLayerIds.Values)
        {
            if (_spriteSystem.LayerMapTryGet((spriteEntity, sprite), layerId, out var layerIndex, false))
            {
                _spriteSystem.LayerMapRemove((spriteEntity, sprite), layerId);
                _spriteSystem.RemoveLayer((spriteEntity, sprite), layerIndex);
            }
        }
        _highlightLayerIds.Clear();

        if (_selectedBodyPart.HasValue)
        {
            var part = _selectedBodyPart.Value;
            string enumName = Enum.GetName(typeof(TargetBodyPart), part) ?? "torso";
            string partName = enumName.ToLowerInvariant();
            string layerId = $"surgery-highlight-{partName}";

            if (!BodyPartToLayerMap.TryGetValue(part, out var bodyPartLayer))
                return;

            try
            {
                if (!_spriteSystem.TryGetLayer((spriteEntity, sprite), bodyPartLayer, out var bodyPartLayerData, false))
                {
                    var layerName = bodyPartLayer.ToString();
                    if (!_spriteSystem.LayerMapTryGet((spriteEntity, sprite), layerName, out var namedLayerIndex, false) ||
                        !_spriteSystem.TryGetLayer((spriteEntity, sprite), namedLayerIndex, out bodyPartLayerData, false))
                    {
                        return;
                    }
                }

                var bodyPartTexture = bodyPartLayerData.Texture;
                if (bodyPartTexture == null)
                {
                    if (bodyPartLayerData.RSI != null && bodyPartLayerData.State != null)
                    {
                        var rsiState = bodyPartLayerData.RSI[bodyPartLayerData.State];
                        if (rsiState != null)
                        {
                            bodyPartTexture = rsiState.GetFrame(RsiDirection.South, 0);
                        }
                    }

                    if (bodyPartTexture == null)
                        return;
                }

                var layerIndex = _spriteSystem.AddTextureLayer((spriteEntity, sprite), bodyPartTexture);
                _spriteSystem.LayerMapSet((spriteEntity, sprite), layerId, layerIndex);
                _spriteSystem.LayerSetOffset((spriteEntity, sprite), layerIndex, bodyPartLayerData.Offset);
                _spriteSystem.LayerSetRotation((spriteEntity, sprite), layerIndex, bodyPartLayerData.Rotation);
                _spriteSystem.LayerSetScale((spriteEntity, sprite), layerIndex, bodyPartLayerData.Scale);

                var solidRed = new Color(1.0f, 0.0f, 0.0f, 1.0f);
                _spriteSystem.LayerSetColor((spriteEntity, sprite), layerIndex, solidRed);
                _spriteSystem.LayerSetVisible((spriteEntity, sprite), layerIndex, true);

                _highlightLayerIds[part] = layerId;
            }
            catch
            {
                return;
            }
        }
    }

    [Obsolete("Controls should only be removed from UI tree instead of being disposed")]
    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);

        if (disposing)
        {
            SpriteView.OnKeyBindDown -= OnSpriteViewClick;
            CleanupSurgeryMode();
        }
    }

    private void PopulateHealthMode(HealthAnalyzerUiState state, EntityUid target, DamageableComponent damageable)
    {
        // Show health mode containers, hide integrity container
        PatientDataContainer.Visible = true;
        GroupsContainer.Visible = true;
        IntegrityContainer.Visible = false;

        // Scan Mode

        ScanModeLabel.Text = state.ScanMode.HasValue
            ? state.ScanMode.Value
                ? Loc.GetString("health-analyzer-window-scan-mode-active")
                : Loc.GetString("health-analyzer-window-scan-mode-inactive")
            : Loc.GetString("health-analyzer-window-entity-unknown-text");

        ScanModeLabel.FontColorOverride = state.ScanMode.HasValue && state.ScanMode.Value ? Color.Green : Color.Red;

        // Patient Information

        SpriteView.SetEntity(target);
        SpriteView.Visible = state.ScanMode.HasValue && state.ScanMode.Value;
        NoDataTex.Visible = !SpriteView.Visible;

        var name = new FormattedMessage();
        name.PushColor(Color.White);
        name.AddText(_entityManager.HasComponent<MetaDataComponent>(target)
            ? Identity.Name(target, _entityManager)
            : Loc.GetString("health-analyzer-window-entity-unknown-text"));
        NameLabel.SetMessage(name);

        SpeciesLabel.Text =
            _entityManager.TryGetComponent<HumanoidAppearanceComponent>(target,
                out var humanoidAppearanceComponent)
                ? Loc.GetString(_prototypes.Index<SpeciesPrototype>(humanoidAppearanceComponent.Species).Name)
                : Loc.GetString("health-analyzer-window-entity-unknown-species-text");

        // Basic Diagnostic

        TemperatureLabel.Text = !float.IsNaN(state.Temperature)
            ? $"{state.Temperature - Atmospherics.T0C:F1} °C ({state.Temperature:F1} K)"
            : Loc.GetString("health-analyzer-window-entity-unknown-value-text");

        BloodLabel.Text = !float.IsNaN(state.BloodLevel)
            ? $"{state.BloodLevel * 100:F1} %"
            : Loc.GetString("health-analyzer-window-entity-unknown-value-text");

        StatusLabel.Text =
            _entityManager.TryGetComponent<MobStateComponent>(target, out var mobStateComponent)
                ? GetStatus(mobStateComponent.CurrentState)
                : Loc.GetString("health-analyzer-window-entity-unknown-text");

        // Total Damage

        DamageLabel.Text = damageable.TotalDamage.ToString();

        // Alerts

        var showAlerts = state.Unrevivable == true || state.Bleeding == true;

        AlertsDivider.Visible = showAlerts;
        AlertsContainer.Visible = showAlerts;

        if (showAlerts)
            AlertsContainer.RemoveAllChildren();

        if (state.Unrevivable == true)
            AlertsContainer.AddChild(new RichTextLabel
            {
                Text = Loc.GetString("health-analyzer-window-entity-unrevivable-text"),
                Margin = new Thickness(0, 4),
                MaxWidth = 300
            });

        if (state.Bleeding == true)
            AlertsContainer.AddChild(new RichTextLabel
            {
                Text = Loc.GetString("health-analyzer-window-entity-bleeding-text"),
                Margin = new Thickness(0, 4),
                MaxWidth = 300
            });

        // Damage Groups

        var damageSortedGroups =
            damageable.DamagePerGroup.OrderByDescending(damage => damage.Value)
                .ToDictionary(x => x.Key, x => x.Value);

        IReadOnlyDictionary<string, FixedPoint2> damagePerType = damageable.Damage.DamageDict;

        DrawDiagnosticGroups(damageSortedGroups, damagePerType);
    }

    private void PopulateIntegrityMode(HealthAnalyzerUiState state)
    {
        // Show integrity container, hide health mode containers
        PatientDataContainer.Visible = false;
        GroupsContainer.Visible = false;
        IntegrityContainer.Visible = true;
        AlertsDivider.Visible = false;
        AlertsContainer.Visible = false;

        // Check if integrity data is available
        if (!state.MaxIntegrity.HasValue || !state.UsedIntegrity.HasValue)
        {
            IntegrityHeaderLabel.Text = Loc.GetString("health-analyzer-integrity-none");
            IntegrityBreakdownContainer.RemoveAllChildren();
            return;
        }

        var maxIntegrity = state.MaxIntegrity.Value;
        var usedIntegrity = state.UsedIntegrity.Value;
        var temporaryBonus = state.TemporaryIntegrityBonus ?? FixedPoint2.Zero;
        var effectiveMax = FixedPoint2.New(maxIntegrity) + temporaryBonus;

        // Set header text
        if (temporaryBonus > 0)
        {
            IntegrityHeaderLabel.Text = Loc.GetString("health-analyzer-integrity-header-bonus",
                ("used", usedIntegrity),
                ("max", effectiveMax),
                ("bonus", temporaryBonus));
        }
        else
        {
            IntegrityHeaderLabel.Text = Loc.GetString("health-analyzer-integrity-header",
                ("used", usedIntegrity),
                ("max", FixedPoint2.New(maxIntegrity)));
        }

        // Clear and populate breakdown
        IntegrityBreakdownContainer.RemoveAllChildren();

        if (state.IntegrityBreakdown != null && state.IntegrityBreakdown.Count > 0)
        {
            foreach (var entry in state.IntegrityBreakdown)
            {
                var label = new Label();
                var color = entry.ComponentType switch
                {
                    "organ" => Color.White,
                    "limb" => Color.Cyan,
                    "cybernetic" => Color.Yellow,
                    "surgery_penalty" => Color.Red,
                    _ => Color.White
                };

                label.FontColorOverride = color;

                if (entry.ComponentType == "surgery_penalty")
                {
                    label.Text = Loc.GetString("health-analyzer-integrity-surgery-penalty",
                        ("cost", entry.IntegrityCost),
                        ("partName", entry.ComponentName));
                }
                else
                {
                    label.Text = Loc.GetString("health-analyzer-integrity-component",
                        ("cost", entry.IntegrityCost),
                        ("name", entry.ComponentName));
                }

                IntegrityBreakdownContainer.AddChild(label);
            }
        }
        else
        {
            var noUsageLabel = new Label
            {
                Text = Loc.GetString("health-analyzer-integrity-none")
            };
            IntegrityBreakdownContainer.AddChild(noUsageLabel);
        }

        // Show bio-rejection if present
        if (state.CurrentBioRejection.HasValue && state.CurrentBioRejection.Value > 0)
        {
            var bioRejectionText = Loc.GetString("health-analyzer-integrity-biorejection",
                ("damage", state.CurrentBioRejection.Value));
            var bioRejectionLabel = new RichTextLabel
            {
                Text = $"[color=red]{bioRejectionText}[/color]",
                Margin = new Thickness(0, 4),
                MaxWidth = 300
            };
            IntegrityBreakdownContainer.AddChild(bioRejectionLabel);
        }

        // Show warning if over limit
        if (usedIntegrity > effectiveMax)
        {
            var warningLabel = new RichTextLabel
            {
                Text = Loc.GetString("health-analyzer-integrity-overlimit"),
                Margin = new Thickness(0, 4),
                MaxWidth = 300
            };
            IntegrityBreakdownContainer.AddChild(warningLabel);
        }
    }

    private static string GetStatus(MobState mobState)
    {
        return mobState switch
        {
            MobState.Alive => Loc.GetString("health-analyzer-window-entity-alive-text"),
            MobState.Critical => Loc.GetString("health-analyzer-window-entity-critical-text"),
            MobState.Dead => Loc.GetString("health-analyzer-window-entity-dead-text"),
            _ => Loc.GetString("health-analyzer-window-entity-unknown-text"),
        };
    }

    private void DrawDiagnosticGroups(
        Dictionary<string, FixedPoint2> groups,
        IReadOnlyDictionary<string, FixedPoint2> damageDict)
    {
        GroupsContainer.RemoveAllChildren();

        foreach (var (damageGroupId, damageAmount) in groups)
        {
            if (damageAmount == 0)
                continue;

            var groupTitleText = $"{Loc.GetString(
                "health-analyzer-window-damage-group-text",
                ("damageGroup", _prototypes.Index<DamageGroupPrototype>(damageGroupId).LocalizedName),
                ("amount", damageAmount)
            )}";

            var groupContainer = new BoxContainer
            {
                Align = AlignMode.Begin,
                Orientation = LayoutOrientation.Vertical,
            };

            groupContainer.AddChild(CreateDiagnosticGroupTitle(groupTitleText, damageGroupId));

            GroupsContainer.AddChild(groupContainer);

            // Show the damage for each type in that group.
            var group = _prototypes.Index<DamageGroupPrototype>(damageGroupId);

            foreach (var type in group.DamageTypes)
            {
                if (!damageDict.TryGetValue(type, out var typeAmount) || typeAmount <= 0)
                    continue;

                var damageString = Loc.GetString(
                    "health-analyzer-window-damage-type-text",
                    ("damageType", _prototypes.Index<DamageTypePrototype>(type).LocalizedName),
                    ("amount", typeAmount)
                );

                groupContainer.AddChild(CreateDiagnosticItemLabel(damageString.Insert(0, " · ")));
            }
        }
    }

    private Texture GetTexture(string texture)
    {
        var rsiPath = new ResPath("/Textures/Objects/Devices/health_analyzer.rsi");
        var rsiSprite = new SpriteSpecifier.Rsi(rsiPath, texture);

        var rsi = _cache.GetResource<RSIResource>(rsiSprite.RsiPath).RSI;
        if (!rsi.TryGetState(rsiSprite.RsiState, out var state))
        {
            rsiSprite = new SpriteSpecifier.Rsi(rsiPath, "unknown");
        }

        return _spriteSystem.Frame0(rsiSprite);
    }

    private static Label CreateDiagnosticItemLabel(string text)
    {
        return new Label
        {
            Text = text,
        };
    }

    private BoxContainer CreateDiagnosticGroupTitle(string text, string id)
    {
        var rootContainer = new BoxContainer
        {
            Margin = new Thickness(0, 6, 0, 0),
            VerticalAlignment = VAlignment.Bottom,
            Orientation = LayoutOrientation.Horizontal,
        };

        rootContainer.AddChild(new TextureRect
        {
            SetSize = new Vector2(30, 30),
            Texture = GetTexture(id.ToLower())
        });

        rootContainer.AddChild(CreateDiagnosticItemLabel(text));

        return rootContainer;
    }
}
