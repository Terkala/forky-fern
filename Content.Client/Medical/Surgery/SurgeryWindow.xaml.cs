using Content.Client.UserInterface.Controls;
using Content.Shared.Medical.Surgery;
using Content.Shared.Medical;
using Content.Shared.Body;
using Content.Shared.Body.Components;
using Content.Shared.Body.Part;
using Content.Shared.Humanoid;
using Content.Client.Medical.Surgery.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface;
using Robust.Client.UserInterface.XAML;
using Robust.Client.GameObjects;
using Robust.Client.UserInterface.Controls;
using Robust.Client.Graphics;
using Content.Client.Clickable;
using Robust.Client.Input;
using Robust.Client.Utility;
using Robust.Shared.Graphics.RSI;
using Robust.Shared.Utility;
using Robust.Shared.Input;
using Robust.Shared.Maths;
using System.Numerics;
using System.Linq;
using System;

namespace Content.Client.Medical.Surgery;

[GenerateTypedNameReferences]
public sealed partial class SurgeryWindow : Content.Client.UserInterface.Controls.FancyWindow
{
    public event Action<SurgeryLayer>? OnLayerChanged;
    public event Action<NetEntity>? OnStepSelected;
    public event Action<NetEntity, bool>? OnToolMethodSelected; // step, isImprovised
    public event Action<TargetBodyPart?>? OnBodyPartSelected;

    public SurgeryLayer CurrentLayer { get; private set; } = SurgeryLayer.Skin;
    private readonly IEntityManager _entMan;
    private readonly SpriteSystem _spriteSystem;
    private readonly BodySystem _bodySystem;
    private readonly IClickMapManager _clickMapManager;
    private readonly Dictionary<TargetBodyPart, TextureButton> _bodyPartControls;
    internal TargetBodyPart? _selectedBodyPart; // Internal so SurgeryBui can access it
    private TargetBodyPart? _pendingSelection; // Track selection we just sent to server
    private EntityUid? _spriteViewEntity;
    private EntityUid? _lastBodyEntity;
    private readonly Dictionary<TargetBodyPart, string> _highlightLayerIds = new();
    
    // Mapping from HumanoidVisualLayers to TargetBodyPart
    private static readonly Dictionary<HumanoidVisualLayers, TargetBodyPart> LayerToBodyPartMap = new()
    {
        { HumanoidVisualLayers.Head, TargetBodyPart.Head },
        { HumanoidVisualLayers.Chest, TargetBodyPart.Torso },
        { HumanoidVisualLayers.LArm, TargetBodyPart.LeftArm },
        { HumanoidVisualLayers.LHand, TargetBodyPart.LeftHand },
        { HumanoidVisualLayers.RArm, TargetBodyPart.RightArm },
        { HumanoidVisualLayers.RHand, TargetBodyPart.RightHand },
        { HumanoidVisualLayers.LLeg, TargetBodyPart.LeftLeg },
        { HumanoidVisualLayers.LFoot, TargetBodyPart.LeftFoot },
        { HumanoidVisualLayers.RLeg, TargetBodyPart.RightLeg },
        { HumanoidVisualLayers.RFoot, TargetBodyPart.RightFoot },
    };

    // Reverse mapping from TargetBodyPart to HumanoidVisualLayers
    private static readonly Dictionary<TargetBodyPart, HumanoidVisualLayers> BodyPartToLayerMap = new()
    {
        { TargetBodyPart.Head, HumanoidVisualLayers.Head },
        { TargetBodyPart.Torso, HumanoidVisualLayers.Chest },
        { TargetBodyPart.LeftArm, HumanoidVisualLayers.LArm },
        { TargetBodyPart.LeftHand, HumanoidVisualLayers.LHand },
        { TargetBodyPart.RightArm, HumanoidVisualLayers.RArm },
        { TargetBodyPart.RightHand, HumanoidVisualLayers.RHand },
        { TargetBodyPart.LeftLeg, HumanoidVisualLayers.LLeg },
        { TargetBodyPart.LeftFoot, HumanoidVisualLayers.LFoot },
        { TargetBodyPart.RightLeg, HumanoidVisualLayers.RLeg },
        { TargetBodyPart.RightFoot, HumanoidVisualLayers.RFoot },
    };

    public SurgeryWindow(IEntityManager entMan)
    {
        RobustXamlLoader.Load(this);
        _entMan = entMan;
        _spriteSystem = _entMan.System<SpriteSystem>();
        _bodySystem = _entMan.System<BodySystem>();
        _clickMapManager = IoCManager.Resolve<IClickMapManager>();

        // Map buttons to TargetBodyPart - sprite is standing up, so buttons map directly to body parts
        // Note: Buttons are now hidden but kept for backward compatibility
        _bodyPartControls = new Dictionary<TargetBodyPart, TextureButton>
        {
            { TargetBodyPart.Head, HeadButton },
            { TargetBodyPart.Torso, ChestButton },
            { TargetBodyPart.LeftArm, LeftArmButton },
            { TargetBodyPart.LeftHand, LeftHandButton },
            { TargetBodyPart.RightArm, RightArmButton },
            { TargetBodyPart.RightHand, RightHandButton },
            { TargetBodyPart.LeftLeg, LeftLegButton },
            { TargetBodyPart.LeftFoot, LeftFootButton },
            { TargetBodyPart.RightLeg, RightLegButton },
            { TargetBodyPart.RightFoot, RightFootButton },
        };

        foreach (var bodyPartButton in _bodyPartControls)
        {
            bodyPartButton.Value.MouseFilter = MouseFilterMode.Stop;
            bodyPartButton.Value.OnPressed += _ => SetActiveBodyPart(bodyPartButton.Key);
        }

        // Subscribe to SpriteView clicks for body part selection
        SpriteView.OnKeyBindDown += OnSpriteViewClick;
        SpriteView.MouseFilter = MouseFilterMode.Stop; // Enable mouse events

        SkinTabButton.OnPressed += _ => SetLayer(SurgeryLayer.Skin);
        TissueTabButton.OnPressed += _ => SetLayer(SurgeryLayer.Tissue);
        OrganTabButton.OnPressed += _ => SetLayer(SurgeryLayer.Organ);

        // Default to torso selection
        _selectedBodyPart = TargetBodyPart.Torso;
        UpdateBodyPartButtons();
    }

    private void SetActiveBodyPart(TargetBodyPart part)
    {
        _selectedBodyPart = part;
        _pendingSelection = part; // Track that we just selected this
        UpdateBodyPartButtons();
        UpdateBodyPartHighlight();
        OnBodyPartSelected?.Invoke(part);
    }

    private void OnSpriteViewClick(GUIBoundKeyEventArgs args)
    {
        // Only handle mouse clicks
        if (args.Function != EngineKeyFunctions.Use)
            return;

        // Check if sprite entity is ready
        if (_spriteViewEntity == null || !_entMan.TryGetComponent<SpriteComponent>(_spriteViewEntity, out var sprite))
            return;

        var spriteEntity = _spriteViewEntity.Value;

        // Get click position relative to SpriteView control
        // args.RelativePosition is relative to control's top-left in UI pixel coordinates
        var clickPosUI = args.RelativePosition;
        
        // Get all transformation values from SpriteView instance
        var spriteViewScale = SpriteView.Scale;
        var spriteViewUIScale = SpriteView.UIScale;
        var spriteViewSize = SpriteView.Size;
        var spriteViewPixelSize = SpriteView.PixelSize;
        var spriteViewStretch = SpriteView.Stretch;
        var spriteViewOverrideDirection = SpriteView.OverrideDirection;
        
        // Calculate stretch factor (mirroring SpriteView.Draw logic)
        // _spriteSize is calculated in MeasureOverride and is in UI pixels
        // We need to get the actual sprite size to calculate stretch
        var spriteBoundsMeters = _spriteSystem.GetLocalBounds((spriteEntity, sprite));
        // Convert sprite bounds to UI pixels: meters -> world pixels -> UI pixels
        var spriteSizeWorldPixels = spriteBoundsMeters.Size * EyeManager.PixelsPerMeter;
        var spriteSizeUIPixels = spriteSizeWorldPixels * spriteViewScale;
        
        var stretchVec = spriteViewStretch switch
        {
            SpriteView.StretchMode.Fit => Vector2.Min(spriteViewSize / spriteSizeUIPixels, Vector2.One),
            SpriteView.StretchMode.Fill => spriteViewSize / spriteSizeUIPixels,
            _ => Vector2.One,
        };
        var stretch = MathF.Min(stretchVec.X, stretchVec.Y);
        
        // Calculate sprite offset (mirroring SpriteView.Draw logic)
        var spriteOffset = SpriteView.SpriteOffset
            ? Vector2.Zero
            : -(-SpriteView.EyeRotation).RotateVec(sprite.Offset * spriteViewScale) * new Vector2(1, -1) * EyeManager.PixelsPerMeter;
        
        // Convert UI click position to sprite-local coordinates
        // SpriteView.Draw() positions sprite at: PixelSize/2 + offset*stretch*UIScale
        // And scales by: Scale * UIScale * stretch
        
        // Step 1: Convert from UI pixel coordinates (top-left origin, Y+ down) to centered coordinates
        var controlCenter = spriteViewPixelSize / 2f;
        var clickRelativeToCenter = clickPosUI - controlCenter;
        
        // Step 2: Flip Y axis (UI Y+ is down, sprite Y+ is up)
        clickRelativeToCenter = new Vector2(clickRelativeToCenter.X, -clickRelativeToCenter.Y);
        
        // Step 3: Remove sprite offset (if not using SpriteOffset)
        // Offset is applied as: offset * stretch * UIScale, so we need to divide by that
        if (!SpriteView.SpriteOffset)
        {
            var offsetScale = stretch * spriteViewUIScale;
            clickRelativeToCenter -= spriteOffset / offsetScale;
        }
        
        // Step 4: Apply inverse of total scale (Scale * UIScale * stretch)
        var totalScale = spriteViewScale * spriteViewUIScale * stretch;
        var clickInWorldPixels = clickRelativeToCenter / totalScale;
        
        // Step 5: Rotate coordinates 90 degrees counter-clockwise to match sprite orientation
        // The sprite is displayed rotated 90 degrees clockwise (laying down), so we need to
        // rotate the click coordinates counter-clockwise to align with sprite-local coordinates
        // 90 degrees counter-clockwise rotation: (x, y) -> (y, -x)
        var clickRotated = new Vector2(clickInWorldPixels.Y, -clickInWorldPixels.X);
        
        // Step 6: Convert from world pixels to meters (sprite-local coordinates are in meters)
        var clickInMeters = clickRotated / EyeManager.PixelsPerMeter;
        
        // First, check if the click is within the sprite's bounds
        // Note: sprite bounds are in sprite-local coordinates, which are unrotated
        var spriteBounds = spriteBoundsMeters;
        if (!spriteBounds.Contains(clickInMeters))
        {
            // Click is outside sprite bounds - don't select anything
            return;
        }
        
        // Check each body part layer to see which one was clicked
        // Layers are rendered in order (higher index = rendered later = on top)
        // So we'll check all relevant layers and pick the one with highest index that was hit
        
        var hitLayers = new List<(TargetBodyPart bodyPart, int layerIndex)>();
        
        foreach (var (humanoidLayer, targetBodyPart) in LayerToBodyPartMap)
        {
            // Try to find this layer in the sprite
            if (!_spriteSystem.LayerMapTryGet((spriteEntity, sprite), humanoidLayer, out var layerIndex, false))
                continue;
            
            if (!_spriteSystem.TryGetLayer((spriteEntity, sprite), layerIndex, out var layer, false))
                continue;
            
            if (!_spriteSystem.IsVisible(layer))
                continue;
            
            // Convert click position to layer-local coordinates
            var layerClickPos = clickInMeters - layer.Offset;
            
            // Check if this layer's texture is at the click position
            var direction = spriteViewOverrideDirection; // Already nullable Direction?
            var isHit = CheckLayerHit(layer, layerClickPos, direction);
            
            if (isHit)
            {
                // Store this hit with its layer index (higher index = rendered later = on top)
                hitLayers.Add((targetBodyPart, layerIndex));
            }
        }
        
        if (hitLayers.Count > 0)
        {
            // Pick the layer with the highest index (topmost, rendered last)
            var topmostHit = hitLayers.OrderByDescending(x => x.layerIndex).First();
            SetActiveBodyPart(topmostHit.bodyPart);
        }
        
        // No body part was hit at this click location - don't change selection
    }

    private void UpdateBodyPartHighlight()
    {
        if (_spriteViewEntity == null || !_entMan.TryGetComponent<SpriteComponent>(_spriteViewEntity, out var sprite))
            return;

        var spriteEntity = _spriteViewEntity.Value;

        // Remove all existing highlight layers
        foreach (var layerId in _highlightLayerIds.Values)
        {
            if (_spriteSystem.LayerMapTryGet((spriteEntity, sprite), layerId, out var layerIndex, false))
            {
                _spriteSystem.LayerMapRemove((spriteEntity, sprite), layerId);
                _spriteSystem.RemoveLayer((spriteEntity, sprite), layerIndex);
            }
        }
        _highlightLayerIds.Clear();

        // Add highlight for selected body part
        if (_selectedBodyPart.HasValue)
        {
            var part = _selectedBodyPart.Value;
            string enumName = Enum.GetName(typeof(TargetBodyPart), part) ?? "torso";
            string partName = enumName.ToLowerInvariant();
            string layerId = $"surgery-highlight-{partName}";
            
            // Find the corresponding body part layer to copy its texture and position
            if (!BodyPartToLayerMap.TryGetValue(part, out var bodyPartLayer))
                return;
            
            try
            {
                // Try to find the body part layer
                if (!_spriteSystem.TryGetLayer((spriteEntity, sprite), bodyPartLayer, out var bodyPartLayerData, false))
                {
                    // Try by string name as fallback
                    var layerName = bodyPartLayer.ToString();
                    if (!_spriteSystem.LayerMapTryGet((spriteEntity, sprite), layerName, out var namedLayerIndex, false) ||
                        !_spriteSystem.TryGetLayer((spriteEntity, sprite), namedLayerIndex, out bodyPartLayerData, false))
                    {
                        return; // Can't find the layer, skip highlighting
                    }
                }
                
                // Get the texture from the body part layer
                var bodyPartTexture = bodyPartLayerData.Texture;
                if (bodyPartTexture == null)
                {
                    // Try to get texture from RSI state if available
                    if (bodyPartLayerData.RSI != null && bodyPartLayerData.State != null)
                    {
                        var rsiState = bodyPartLayerData.RSI[bodyPartLayerData.State];
                        if (rsiState != null)
                        {
                            // Get frame 0 of the current direction
                            bodyPartTexture = rsiState.GetFrame(RsiDirection.South, 0);
                        }
                    }
                    
                    if (bodyPartTexture == null)
                        return; // No texture available
                }
                
                // Create a new layer with the same texture as the body part, positioned at the same offset
                // This layer will render on top since it's added last to the sprite component
                // This layer will render on top since it's added last
                var layerIndex = _spriteSystem.AddTextureLayer((spriteEntity, sprite), bodyPartTexture);
                _spriteSystem.LayerMapSet((spriteEntity, sprite), layerId, layerIndex);
                
                // Copy the offset from the original layer
                _spriteSystem.LayerSetOffset((spriteEntity, sprite), layerIndex, bodyPartLayerData.Offset);
                
                // Copy other transform properties to match the original layer
                _spriteSystem.LayerSetRotation((spriteEntity, sprite), layerIndex, bodyPartLayerData.Rotation);
                _spriteSystem.LayerSetScale((spriteEntity, sprite), layerIndex, bodyPartLayerData.Scale);
                
                // Set color to solid red - this will make the entire texture appear as pure red
                // Since sprite base color is white (1,1,1,1) and layer color is (1,0,0,1),
                // the result will be (1,0,0,1) which is pure red
                var solidRed = new Color(1.0f, 0.0f, 0.0f, 1.0f);
                _spriteSystem.LayerSetColor((spriteEntity, sprite), layerIndex, solidRed);
                
                // Make sure the layer is visible
                _spriteSystem.LayerSetVisible((spriteEntity, sprite), layerIndex, true);
                
                _highlightLayerIds[part] = layerId;
            }
            catch
            {
                // If anything fails, skip highlighting for this part
                return;
            }
        }
    }

    private void UpdateBodyPartButtons()
    {
        foreach (var (part, button) in _bodyPartControls)
        {
            button.Pressed = part == _selectedBodyPart;
        }
    }

    private void SetLayer(SurgeryLayer layer)
    {
        CurrentLayer = layer;
        OnLayerChanged?.Invoke(layer);
        // Update buttons will be called from UpdateState with proper state
    }

    public void UpdateState(SurgeryBoundUserInterfaceState state)
    {
        // Update sprite view with body entity
        var bodyPartEntity = _entMan.GetEntity(state.BodyPart);
        EntityUid? bodyEntity = null;
        
        if (_entMan.TryGetComponent<BodyPartComponent>(bodyPartEntity, out var bodyPartComp))
        {
            bodyEntity = bodyPartComp.Body;
        }
        else if (_entMan.TryGetComponent<BodyComponent>(bodyPartEntity, out _))
        {
            // If the BodyPart is actually the body itself
            bodyEntity = bodyPartEntity;
        }

        bool needsSpriteCopy = false;
        if (bodyEntity != null)
        {
            // Create or update sprite view entity for highlighting
            if (_spriteViewEntity == null || _entMan.Deleted(_spriteViewEntity))
            {
                _spriteViewEntity = _entMan.Spawn("AlertSpriteView");
            }

            // Only copy sprite if the body entity changed (to avoid clearing highlights on every update)
            needsSpriteCopy = _lastBodyEntity != bodyEntity.Value;
            if (needsSpriteCopy)
            {
                // Copy body sprite to our view entity
                if (_entMan.TryGetComponent<SpriteComponent>(bodyEntity.Value, out var bodySprite) &&
                    _entMan.TryGetComponent<SpriteComponent>(_spriteViewEntity, out var viewSprite))
                {
                    _spriteSystem.CopySprite((bodyEntity.Value, bodySprite), (_spriteViewEntity.Value, viewSprite));
                    
                    // Note: SpriteView.Scale in XAML handles the scaling, so we don't need to scale layers here
                    // Highlights will be re-applied below if we have a selection
                }
                _lastBodyEntity = bodyEntity.Value;
            }

            SpriteView.SetEntity(_spriteViewEntity.Value);
            // Force sprite to stand up (South direction) to match button layout
            SpriteView.OverrideDirection = Robust.Shared.Maths.Direction.South;
            SpriteView.Visible = true;
            PartView.Visible = false; // Hidden - using sprite-based clicking instead
        }
        else
        {
            SpriteView.Visible = false;
            PartView.Visible = false;
            _lastBodyEntity = null;
        }

        // Update selected body part from state, but only if state has a value
        // Don't override user selection if we just sent a selection message (pending)
        var selectionChanged = UpdateSelectedBodyPartFromState(state.SelectedTargetBodyPart);
        
        // Update UI if selection changed or if sprite was copied (highlights need re-applying)
        if (selectionChanged || needsSpriteCopy)
        {
            UpdateBodyPartButtons();
            UpdateBodyPartHighlight();
        }

        // Update layer buttons - disable if not accessible
        UpdateLayerButtons(state);

        // Clear and refresh the step list - steps are already filtered by the selected body part on the server
        // When a body part is clicked, the server filters steps for that body part and sends them in the state
        StepsContainer.RemoveAllChildren();

        List<NetEntity> steps;
        bool layerAccessible = false;

        // Get steps for the current layer - these are already filtered by the selected body part (state.SelectedBodyPart)
        switch (CurrentLayer)
        {
            case SurgeryLayer.Skin:
                steps = state.SkinSteps; // Steps filtered for selected body part
                layerAccessible = true; // Skin layer is always accessible
                break;
            case SurgeryLayer.Tissue:
                steps = state.TissueSteps; // Steps filtered for selected body part
                layerAccessible = state.CanAccessTissueLayer; // Use state flag
                break;
            case SurgeryLayer.Organ:
                steps = state.OrganSteps; // Steps filtered for selected body part
                layerAccessible = state.CanAccessOrganLayer; // Use state flag
                break;
            default:
                steps = new List<NetEntity>();
                break;
        }

        if (!layerAccessible)
        {
            var label = new Robust.Client.UserInterface.Controls.Label 
            { 
                Text = Loc.GetString("surgery-window-layer-inaccessible", 
                    ("layer", Loc.GetString($"surgery-window-layer-{CurrentLayer.ToString().ToLower()}")))
            };
            StepsContainer.AddChild(label);
            return;
        }

        if (steps.Count == 0)
        {
            var label = new Robust.Client.UserInterface.Controls.Label { Text = Loc.GetString("surgery-window-no-steps") };
            StepsContainer.AddChild(label);
            return;
        }

        foreach (var stepNetEntity in steps)
        {
            // Get operation info for this step
            state.StepOperationInfo.TryGetValue(stepNetEntity, out var operationInfo);

            // Create hierarchical step control
            var stepControl = new SurgeryStepControl(
                _entMan,
                stepNetEntity,
                operationInfo,
                CurrentLayer
            );

            stepControl.OnStepSelected += (step) => OnStepSelected?.Invoke(step);
            stepControl.OnToolMethodSelected += (step, isImprovised) => OnToolMethodSelected?.Invoke(step, isImprovised);

            StepsContainer.AddChild(stepControl);
        }
    }

    private void UpdateLayerButtons(SurgeryBoundUserInterfaceState? state = null)
    {
        SkinTabButton.Pressed = CurrentLayer == SurgeryLayer.Skin;
        TissueTabButton.Pressed = CurrentLayer == SurgeryLayer.Tissue;
        OrganTabButton.Pressed = CurrentLayer == SurgeryLayer.Organ;

        // Disable layer buttons if not accessible (skin is always accessible)
        if (state != null)
        {
            TissueTabButton.Disabled = !state.CanAccessTissueLayer;
            OrganTabButton.Disabled = !state.CanAccessOrganLayer;
        }
    }

    [Obsolete("Controls should only be removed from UI tree instead of being disposed")]
    protected override void Dispose(bool disposing)
    {
        base.Dispose(disposing);

        // Clean up the sprite view entity - it's only used for UI rendering, not world rendering
        if (disposing && _spriteViewEntity != null && !_entMan.Deleted(_spriteViewEntity))
        {
            _entMan.QueueDeleteEntity(_spriteViewEntity);
            _spriteViewEntity = null;
        }
    }

    #region Helper Methods

    /// <summary>
    /// Checks if a click position hits a sprite layer (texture or RSI).
    /// </summary>
    private bool CheckLayerHit(SpriteComponent.Layer layer, Vector2 layerClickPos, Direction? overrideDirection = null)
    {
        Vector2i imagePos;
        Vector2i size;
        
        if (layer.Texture != null)
        {
            size = layer.Texture.Size;
            imagePos = (Vector2i)(layerClickPos * EyeManager.PixelsPerMeter * new Vector2(1, -1) + size / 2f);
            
            if (imagePos.X >= 0 && imagePos.X < size.X && imagePos.Y >= 0 && imagePos.Y < size.Y)
            {
                return _clickMapManager.IsOccluding(layer.Texture, imagePos);
            }
        }
        else if (layer.RSI != null && layer.State != null)
        {
            var rsiState = layer.RSI[layer.State];
            if (rsiState == null)
                return false;
                
            size = rsiState.Size;
            var direction = RsiDirection.South; // Default to South (standing up)
            if (overrideDirection.HasValue)
            {
                // Convert Direction to RsiDirection - need RsiDirectionType from the state
                var dirType = rsiState.RsiDirections;
                direction = overrideDirection.Value.Convert(dirType);
            }
            var frame = 0; // Use frame 0 for click detection
            imagePos = (Vector2i)(layerClickPos * EyeManager.PixelsPerMeter * new Vector2(1, -1) + size / 2f);
            
            if (imagePos.X >= 0 && imagePos.X < size.X && imagePos.Y >= 0 && imagePos.Y < size.Y)
            {
                return _clickMapManager.IsOccluding(layer.RSI, layer.State, direction, frame, imagePos);
            }
        }
        
        return false;
    }

    /// <summary>
    /// Updates the selected body part from server state, handling pending selections.
    /// </summary>
    private bool UpdateSelectedBodyPartFromState(TargetBodyPart? stateSelection)
    {
        bool changed = false;
        
        if (stateSelection.HasValue)
        {
            // If we have a pending selection, only accept matching updates
            if (_pendingSelection.HasValue)
            {
                if (stateSelection.Value == _pendingSelection.Value)
                {
                    _pendingSelection = null;
                    if (stateSelection.Value != _selectedBodyPart)
                    {
                        _selectedBodyPart = stateSelection.Value;
                        changed = true;
                    }
                }
            }
            else if (stateSelection.Value != _selectedBodyPart)
            {
                _selectedBodyPart = stateSelection.Value;
                changed = true;
            }
        }
        else if (_selectedBodyPart == null && !_pendingSelection.HasValue)
        {
            _selectedBodyPart = TargetBodyPart.Torso;
            changed = true;
        }
        
        return changed;
    }

    #endregion
}

