// SPDX-FileCopyrightText: 2022 Rinkashikachi <15rinkashikachi15@gmail.com>
// SPDX-FileCopyrightText: 2022 Leon Friedrich <60421075+ElectroJr@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Kara <lunarautomaton6@gmail.com>
// SPDX-FileCopyrightText: 2022 Rane <60792108+Elijahrane@users.noreply.github.com>
// SPDX-FileCopyrightText: 2022 Fishfish458 <47410468+Fishfish458@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023-2024 Whisper <121047731+QuietlyWhisper@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Artjom <artjombebenin@gmail.com>
// SPDX-FileCopyrightText: 2023 metalgearsloth <31366439+metalgearsloth@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 MilenVolf <63782763+MilenVolf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 DrSmugleaf <DrSmugleaf@users.noreply.github.com>
// SPDX-FileCopyrightText: 2023 Visne <39844191+Visne@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Saphire Lattice <lattice@saphi.re>
// SPDX-FileCopyrightText: 2024 goet <6637097+goet@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Thomas <87614336+Aeshus@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 KrasnoshchekovPavel <119816022+KrasnoshchekovPavel@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 TsjipTsjip <19798667+TsjipTsjip@users.noreply.github.com>
// SPDX-FileCopyrightText: 2024 Rainfey <rainfey0+github@gmail.com>
// SPDX-FileCopyrightText: 2024 Pieter-Jan Briers <pieterjan.briers+git@gmail.com>
// SPDX-FileCopyrightText: 2024 Krunklehorn <42424291+Krunklehorn@users.noreply.github.com>
// SPDX-FileCopyrightText: 2025 Hannah Giovanna Dawson <karakkaraz@gmail.com>
// SPDX-FileCopyrightText: 2025 LordCarve <27449516+LordCarve@users.noreply.github.com>
// SPDX-FileCopyrightText: 2026 Fruitsalad <949631+Fruitsalad@users.noreply.github.com>
// SPDX-License-Identifier: MIT

using Content.Client.UserInterface.Controls;
using Content.Client.Medical.Surgery.Controls;
using Content.Shared.Medical;
using Content.Shared.MedicalScanner;
using Content.Shared.Medical.Surgery;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Client.UserInterface.Controls;
using Robust.Client.GameObjects;
using Robust.Shared.IoC;

namespace Content.Client.HealthAnalyzer.UI;

public enum HealthAnalyzerMode
{
    Health,
    Integrity,
    Surgery
}

[GenerateTypedNameReferences]
public sealed partial class HealthAnalyzerWindow : FancyWindow
{
    private NetEntity? _currentTargetEntity;
    private HealthAnalyzerMode _currentMode = HealthAnalyzerMode.Health;
    private HealthAnalyzerUiState? _currentState;
    private readonly IEntityManager _entMan;

    public event Action<NetEntity, NetEntity, SurgeryLayer, TargetBodyPart?, bool>? OnAttemptSurgery;

    public HealthAnalyzerWindow()
    {
        RobustXamlLoader.Load(this);
        _entMan = IoCManager.Resolve<IEntityManager>();

        HealthButton.OnPressed += _ => SetMode(HealthAnalyzerMode.Health);

        // Subscribe to mode button presses
        HealthModeButton.OnPressed += _ => SetMode(HealthAnalyzerMode.Health);
        IntegrityModeButton.OnPressed += _ => SetMode(HealthAnalyzerMode.Integrity);
        SurgeryModeButton.OnPressed += _ => SetMode(HealthAnalyzerMode.Surgery);

        // Surgery button hidden until we receive state with valid surgical target
        SurgeryModeButton.Visible = false;

        // Set initial mode
        SetMode(HealthAnalyzerMode.Health);
    }

    public void Populate(HealthAnalyzerScannedUserMessage msg)
    {
        _currentState = msg.State;
        _currentTargetEntity = msg.State.TargetEntity;

        // Surgery mode button only visible when target is valid surgical target
        var isValidSurgicalTarget = msg.State.SurgerySteps != null && msg.State.SurgerySteps.Count > 0;
        SurgeryModeButton.Visible = isValidSurgicalTarget;

        // If target became invalid while in Surgery mode, switch back to Health
        if (_currentMode == HealthAnalyzerMode.Surgery && !isValidSurgicalTarget)
        {
            SetMode(HealthAnalyzerMode.Health);
        }
        else
        {
            HealthAnalyzerControl.Populate(msg.State, _currentMode, allowSurgery: true);
        }

        UpdateSurgeryUI();
    }
    
    private void SetMode(HealthAnalyzerMode mode)
    {
        _currentMode = mode;
        
        // Update button pressed states
        HealthModeButton.Pressed = mode == HealthAnalyzerMode.Health;
        IntegrityModeButton.Pressed = mode == HealthAnalyzerMode.Integrity;
        SurgeryModeButton.Pressed = mode == HealthAnalyzerMode.Surgery;
        
        // Update UI visibility
        if (_currentState.HasValue)
        {
            HealthAnalyzerControl.Populate(_currentState.Value, mode, allowSurgery: true);
        }
        
        // Update surgery UI based on mode
        UpdateSurgeryUI();
    }
    
    private void UpdateSurgeryUI()
    {
        bool showSurgeryPanel = _currentMode == HealthAnalyzerMode.Surgery && _currentTargetEntity != null;
        SurgeryPanel.Visible = showSurgeryPanel;

        // Health button visible when in Surgery mode - switches back to Health mode
        HealthButton.Visible = showSurgeryPanel;

        if (showSurgeryPanel && _currentState.HasValue)
        {
            PopulateSurgerySteps(_currentState.Value);
        }
        else
        {
            SurgeryStepsContainer.RemoveAllChildren();
        }
    }
    
    private void PopulateSurgerySteps(HealthAnalyzerUiState state)
    {
        SurgeryStepsContainer.RemoveAllChildren();
        
        if (state.SurgerySteps == null || state.SurgerySteps.Count == 0)
        {
            var label = new Label { Text = "No surgery operations available." };
            SurgeryStepsContainer.AddChild(label);
            return;
        }
        
        var currentLayer = state.CurrentSurgeryLayer ?? SurgeryLayer.Skin;

        foreach (var stepNetEntity in state.SurgerySteps)
        {
            SurgeryStepOperationInfo? operationInfo = null;
            state.SurgeryStepOperationInfo?.TryGetValue(stepNetEntity, out operationInfo);

            var stepControl = new SurgeryStepControl(
                _entMan,
                stepNetEntity,
                operationInfo,
                currentLayer
            );

            stepControl.OnStepSelected += (step) =>
            {
                if (_currentTargetEntity != null)
                {
                    // Use current selection from control - sent with step to prevent miscommunication
                    OnAttemptSurgery?.Invoke(step, _currentTargetEntity.Value, currentLayer, HealthAnalyzerControl.SelectedBodyPart, false);
                }
            };

            stepControl.OnToolMethodSelected += (step, isImprovised) =>
            {
                if (_currentTargetEntity != null)
                {
                    OnAttemptSurgery?.Invoke(step, _currentTargetEntity.Value, currentLayer, HealthAnalyzerControl.SelectedBodyPart, isImprovised);
                }
            };

            SurgeryStepsContainer.AddChild(stepControl);
        }
    }
}
